---
title: "[Under Construction] HEVD Driver Exploitation - Part 3A: Arbitrary Memory Overwrite (Token Stealing)"
date: 2020-10-20
tags: [posts]
excerpt: "Covering another vulnerability in the HackSys HEVD driver - Arbitrary Memory Overwrite"
---
Overview
---
In my last post in this series, I talked about exploiting stack buffer overflows. I highly recommend walking through that [post](https://jb05s.github.io/HEVD-Driver-Exploitation-Part-2-Stack-Overflow-Presented-in-Python-and-C/) to get comfortable with performing driver analysis, if this is your first time attacking Windows kernel drivers.

In this two-part post, I'd like to talk about another vulnerability HackSys implemented into their driver - Arbitrary Memory Overwrite. The first part will start off by covering driver analysis and understanding the vulnerability. Then we'll jump right into building our exploit with the goal of escalating our privileges to `NT Authority\SYSTEM` using the `Token Stealing` technique that was covered in the stack buffer overflow post. 

In the second part of this post I'll walk through another privilege escalation technique - `_SEP_TOKEN_PRIVILEGES`.

Driver Analysis
---
For performing driver analysis, in my previous post, I went into great detail on what we're needing to enumerate. Again, if you haven't read through that post and it's your first time performing driver analysis, I highly recommend you check it out.

As a quick overview, we're trying to identify a couple things during the analysis. We first need to fingerprint the symbolic link that the driver is exposing. The symbolic link is used for clients to interact with the driver by opening an object handle. A great option for quickly identifying the driver's symbolic link is through the `IoCreateDevice` function in `IDA - Imports`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-imports-iocreatedevice-devicename.png" alt="">

Along with identifying the driver's symbolic link, we also need to identify and calulcate the IO Control code for where the issue is located in the vulnerable driver. Since the HEVD driver was created for educational purposes, it's quite user-friendly - all subroutines are nicely named and there's a fairly good amount of debugging comments. We can almost effortlessly identitify the IO Control Codes supported by the HEVD driver through IDA with the `IofCompleteRequest` imports function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-imports-iofcompleterequest-ioctlcodes.png" alt="">

From here, we can calculate the IO Control Code that leads us to the arbitrary memory overwrite issue.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-irpdeviceiocontrolhandler.png" alt="">

Now that we've identified the symbolic link for us to open a handle to the driver object and the IO Control Code that contains the issue, we can start analyzing the code to see how we can trigger the vulnerability.

Bug Analysis
---
<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-function-search.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/hevd-amo-code.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/amo-vuln.png" alt="">

Exploitation - Windows 7 SP1 (x64)
---
Initial exploit code in C:  
<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/exploit-c-code-1.png" alt="">

Initial exploit code in Python:  
<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/exploit-python-code-1.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/windbg-trigger-amo-output.png" alt="">

HalDispatchTable
---

Defeating Address Space Layout Randomization (ASLR)
---

Token Stealing Shellcode - x64
---

ones-and-zer0es
---

Wrapping Up
---