---
title: "[Under Construction] HEVD Driver Exploitation - Part 3A: Arbitrary Memory Overwrite (Token Stealing)"
date: 2020-09-25
tags: [posts]
excerpt: "Covering another vulnerability in the HackSys HEVD driver - Arbitrary Memory Overwrite"
---
Overview
---
In my last post in this series, I talked about exploiting stack buffer overflows. I highly recommend walking through that [post](https://jb05s.github.io/HEVD-Driver-Exploitation-Part-2-Stack-Overflow-Presented-in-Python-and-C/) to get comfortable with performing driver analysis, especially if this is your first time attacking Windows kernel drivers.

In this two-part post, I'd like to talk about another vulnerability HackSys implemented into their driver - Arbitrary Memory Overwrite. The first part will start off by covering driver analysis and understanding the vulnerability. Then we'll jump right into building our exploit with the goal of escalating our privileges to `NT Authority\SYSTEM` using the `Token Stealing` technique that was covered in the stack buffer overflow post. 

In the second part of this post I'll walk through another privilege escalation technique - `_SEP_TOKEN_PRIVILEGES`.

Driver Analysis
---
For performing driver analysis, in my previous post, I went into great detail on what we're needing to enumerate. Again, if you haven't read through that post and it's your first time performing driver analysis, I highly recommend you check it out.

As a quick overview, we're trying to identify a couple things during the analysis. We first need to fingerprint the symbolic link that the driver is exposing. The symbolic link is used for clients to interact with the driver by opening an object handle. A great option for quickly identifying the driver's symbolic link is through the `IoCreateDevice` function in `IDA - Imports`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-imports-iocreatedevice-devicename.png" alt="">

Along with identifying the driver's symbolic link, we also need to identify and calculate the related IO Control code for where the identified issue is located. Since the HEVD driver was created for educational purposes, it's quite user-friendly - all subroutines are nicely named and there's a fairly good amount of debugging comments. We can almost effortlessly identify the IO Control Codes supported by the HEVD driver through IDA with the `IofCompleteRequest` imports function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-imports-iofcompleterequest-ioctlcodes.png" alt="">

From here, we can calculate the IO Control Code that leads us to the arbitrary memory overwrite issue.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-irpdeviceiocontrolhandler.png" alt="">

Now that we've identified the symbolic link for us to open a handle to the driver object, and the IO Control Code that contains the issue, we can start analyzing the code to see how we can trigger the vulnerability.

Bug Analysis
---
Before we start building an exploit, we must first understand what the underlying issue is. An abitrary memory overwrite is an issue where a client has the ability to write data to a controlled location. This issue is commonly referred to as `Write-What-Where` - The user has control over `what` data they'd like to `write`, along with `where` they'd like the data to be written to.

Let's review the source code for the issue in `ArbitraryOverwrite.c` file.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/hevd-amo-code.png" alt="">

As mentioned in the code above, there's no proper validation being performed to check whether the values stored in `What` and `Where` reside in User Mode address space. Validation can be seen in the secured version by utilizing the [ProbeForRead](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread) API function.

Now that we have a good idea of what the underlying issue is, let's jump back into IDA and analyze the `TriggerArbitraryOverwrite` function. We can quickly locate this function in IDA by performing a search in IDA's - `Functions` window.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/ida-function-search.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/amo-vuln.png" alt="">

Upon analysis, we can confirm that there's no proper validation being performed on the `What` and `Where` address pointers. Additionally, we can conclude that both address pointers are being passed in the `lpInBuffer` parameter of the `DeviceIoControl` API function.

With this information, we can begin to build our initial exploit code, to confirm that we indeed control the `What` and `Where` pointers.

Moving forward, here's the information we've collected to trigger the arbitrary memory overwrite issue:
- The symbolic link for opening a handle to the driver object is `"\\\\.\\HackSysExtremeVulnerableDriver"`
- The IO Control Code for making an IRP request to trigger the arbitrary memory overwrite issue is `0x22200B`
- The `What` and `Where` pointers are stored in the `lpInBuffer` parameter of the `DeviceIoControl` API function

Let's begin!

Exploitation - Windows 7 SP1 (x64)
---
Initial exploit code in C:  
<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/exploit-c-code-1.png" alt="">

Initial exploit code in Python:  
<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/exploit-python-code-1.png" alt="">

Let's do a quick review of the code, to make sure there's no stragglers. First, we open a handle to the HEVD driver through the `CreateFileA` API function. Then we utilize the handle created with `CreateFileA` in a call to `DeviceIoControl` to send an IRP request to the HEVD driver. 

The `dwIoControlCode` parameter value passed in `DeviceIoControl` tells the driver that we're wanting to make a request to the routine we identified as having the arbitrary memory overwrite issue. The value passed to the `lpInBuffer` parameter is our `expl` variable. Our `expl` variable is 0x10h in size - the first 0x8h is filled with A's and the other 0x8h is filled with B's. We're intentionally setting these values to initially verify that we have control over the `What` and `Where` pointers.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/windbg-trigger-amo-output.png" alt="">

Perfect! We successfully control the `What` and `Where` pointers. Now that we control these pointers, let's talk about how we can proceed to exploit this vulnerability.

The `What` should be pretty clear to us. We want to write data that will result in escalating our privileges on the local machine. For this, we'll perform the token stealing technique.. which was covered extensively in my previous post.

As for `Where` we want to write our data, we have to do some research. Our goal here is to execute our shellcode in kernel mode. There's a few options available to us to accomplish this. However, in this post we'll be leveraging the `HalDispatchTable`. 

Let's discuss what the HalDispatchTable is and how we can utilize it to accomplish privilege escalation.

HalDispatchTable
---
The [HalDispatchTable (Hardware Abstraction Layer Dispatch Table)](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/hal_dispatch.htm) is part of the Windows kernel. It's used to isolate the operating system from hardware. This essentially means that Windows can run on machines with different hardware, without affecting OS functionality.

The HalDispatchTable is a suitable candidate for our exploit, due to the function located at the offset of 0x8h, on x64 architecture.

At offset 0x8h in the HalDispatchTable structure is the `HalQuerySystemInformation` function. The reason this offset is important is because of an undocumented function - `NtQueryIntervalProfile`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/hal-ntqueryintervalprofile-windbg.png" alt="">

NtQueryIntervalProfile internally calls the `KeQueryIntervalProfie` function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt3a/hal-kequeryintervalprofile-windbg.png" alt="">

Defeating Address Space Layout Randomization (ASLR)
---

Token Stealing Shellcode - x64
---

ones-and-zer0es
---

Wrapping Up
---