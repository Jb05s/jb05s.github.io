---
title:  "Under Construction - HEVD Driver Exploitation - Part 2: Stack Buffer Overflow (Written in both Python and C)"
date:   2020-07-14
tags: [posts]
excerpt: "Aimed to assist individuals who are looking to learn a little about kernel exploitation. In this blog post, we'll cover some of the basics on driver enumeration, then end with exploiting a stack buffer overflow on HEVD. I welcome you to Part 2 of the tutorial series!"
---
Overview
---
In ['Part 1'](https://jb05s.github.io/HEVD-Driver-Exploitation-Part-1/), we went through the process of setting up our debugging environment. In this part, we'll be taking a closer look into the HackSysExtremeVulnerable driver. First, we'll begin by covering some reverse engineering basics (i.e. Driver Enumeration). After we've performed sufficient enumeration of the kernel driver, we'll proceed by looking into the stack buffer overflow bug within the HEVD driver. For the exploitation portion of this post, I'll be demonstrating the exploitation process by writing the code in both Python and C.

Let's get started!

Windows Kernel Drivers
---
To start things off, let's cover what a driver is and how we (as users) can interact with drivers.

(Need to complete this section later..)

Driver Analysis
---
Using IDA, navigate to the `Imports` windows and locate the `IoCreateDevice` function. In order for a client to obtain a handle to a driver object, a driver needs to expose at least one device object. This is created through `IoCreateDevice`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice.png" alt="">

After finding `IoCreateDevice`, double-click on the function, and then right-click on the function and select `Jump to xref to operand`. This will list the all the pointers/references for the function within the driver.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice-references.png" alt="">

As we can see, there's only one reference within the driver for `IoCreateDevice`. Let's process to jump the the reference location to analyze the the surrounding subroutines. What we're looking for within this function is a reference to the name of the device being created within the HEVD.sys driver. This is known as a symbolic link. Symbolic links are used for clients to create a handle to the device object. It allows for interaction to exist between the client and the device driver. Without much effort, we're able to successfully find the call that discloses the name of the device being created, `"\\Device\\HackSysExtremeVulnerableDriver"`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice-devicename.png" alt="">

Following the enumeration of the device name, we also need to identify any and all IO Control codes within HEVD.sys. Every IO Control code, defined by the device driver, performs a unique set of actions. A good way to identify these IO Control codes is through the `IofCompleteRequest` import function in IDA. `IofCompleteRequest` is used to complete IRP requests to the driver. In order for a IRP request to a driver to succeed, a valid IO code needs to be passed to the driver.. making `IofCompleteRequest` a viable function to use for identifying and calculating IO codes accepted by the driver.

Making our way back to the `Imports` window, and performing the same process used for the `IoCreateDevice` function, we can see there's quite a few pointers and references to the `IofCompleteRequest` function. In this list of pointers/references, we see one to `IrpDeviceIoCtlHandler`. This is our point of interest for fingerprinting valid IO codes for IRP requests from clients. You can think of a DeviceIoCtlHandler, or a DeviceIoControl dispatch routine for that matter, as the manager of client IRP requests.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-references.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-refjump.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-ioctlcodes.png" alt="">

After jumping into the reference to `IrpDeviceIoCtlHandler`, and crawling our way to the top of the subroutine, we can begin to identify some Io codes the driver accepts and how to calculate them. For a different viewing of the Io Codes, simply right-click in the window and select `Graph View`, as seen in the figure below. This view can be helpful in visualizing the calculations, and the branches within the `IrpDeviceIoCtlHandler` routine.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-ioctlcodes-graph.png" alt="">

Now that we've identified the symbolic link exposed from the driver and a list of valid IO codes accepted, we can now move forward in identifying the stack overflow bug and then begin building our exploit.

Bug Analysis
---
The first thing we need to do is identify which IO code corresponds to the stack overflow bug. Luckily for us, HEVD is very verbose and makes identifying the bug classes and their associated IO code relatively easy (Don't get used to it!!). With a quick look into the `IrpDeviceIoCtlHandler` routine, and analyzing the conditional jumps for each IO code, we see that the IO code for the stack overflow is `0x222003`.

Now we need to analyze the function and see what needs to be done to trigger the stack overflow.

In IDA, we can navigate over to the `Functions` table and search for function names that contain `stack`. As we'll see, there's several functions that have references to stack overflow. (We will not be covering the /GS stack cookie version in this post).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-functions-stack-overflow.png" alt="">

Jumping into the `TriggerBufferOverflowStack` function, we can analyze what's going on.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-triggerbufferoverflowstack.png" alt="">

In the visual above, we can identify that the buffer buffer size is of 0x800h (2048 in decimal). Analyzing a bit further down, we can notice that the user supplied buffer size is being passed on without validating against the size of the kernel buffer (right before memmove is called). This is also described in the `BufferOverflowStack.c` file, provided by the HackSys Team.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bufferoverflow-sourcecode.png" alt="">

Perfect! Up to this point, we now know the following:
- The symbolic link used by HEVD for client's to open a handle to the driver is `"\\Device\\HackSysExtremeVulnerableDriver"`
- The IO code for making an IRP request to the stack overflow vulnerability is `0x222003`
- The user supplied buffer size needs to be greater than 0x800h (or 2048 decimal) to trigger the bug.

This is enough information for us to begin building our exploit.

Exploitation
---
For the exploitation process, I will be showcasing the code in both Python and C (to show my appreciation for both languages). The first step in the exploit process is to open a handle to the driver object. As mentioned before, this is essential, as it's used for the client to interact with the device driver. This process can be done through the use of the `CreateFileA()` API function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/msdn-createfilea.png" alt="">

As shown in the above snippet, the first parameter (`lpFileName`) is where we'll pass the name of the symbolic link exposed by the device driver. With the handle to the driver object, we then must then initiate interaction with the driver through the `DeviceIoControl()` API function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/msdn-deviceiocontrol.png" alt="">

As you see in the snippet above, we need to pass the handle to the driver object we setup in `CreateFileA()` to `DeviceIoControl()`, as the first parameter. Additionally, in second parameter, we need to supply the IO code we wish to make a request to; which we already identified earlier as `0x222003`. Lastly, parameters three and four (`lpInBuffer` and `nInBufferSize`) is where we need to pass our user supplied buffer. With all these factors taken into account, here's what our initial code will look like.

Initial exploit code in C:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-initial-c.png" alt="">

Initial exploit code in Python:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-initial-py.png" alt="">

Now that our initial PoC is ready, let's jump over to our test environment that we setup in the last post. Once our environment is up and running, and we have a successful COM between the Debugger and Debuggee machines in WinDBG, let's copy over the initial PoC to our Debuggee machine. Before we run our code, let's setup a breakpoint in WinDBG at `TriggerStackOverflow`, to verify whether or not we hit our intended target.

With the breakpoint set, we can now run our PoC on the Debuggee machine to see if we hit our breakpoint and analyze the behavior.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/stack-overflow-no-issue.png" alt="">

As we can see, we hit our breakpoint. However, if we allow execution to continue, the driver fulfills the client request and we don't trigger the underlying bug. That's because we didn't pass a buffer size large enough to overflow into adjacent memory to cause critical data to be overwritten. In the current case, We've merely provided the maximum size in memory set aside for the user buffer.

In our next case, let's try passing a larger user supplied buffer to see if that causes the behavior we're looking for. Instead of passing 0x800h, let's pass a buffer size of 0x900h (2304 in decimal).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-2-py.png" alt="">

With our updated PoC, let's copy it over to the debuggee machine and run it to analyze its behavior (our breakpoint should still be set, so nothing needs to be updated in WinDBG).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit2.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/access-violation-stack1.png" alt="">

Bingo! We've successfully overwritten EIP with the updated user supplied buffer size and hit an access violation. Cool.. so we have a vanilla EIP overwrite, but where do we go from here?

We need to locate the offset in our user supplied buffer at where we control EIP. By finding the offset to EIP, we can control the flow of execution and have the ability to introduce our own code to get executed.

But how can we find the offset? We can introduce a string composed of unique patterns to replace our sequence of 'A's. With this unique pattern, we'll be able to identify the offset of EIP by comparing the bytes stored in EIP, during the time the access violation occurs, to our unique string. There are a lot of great resources out there that assist in creating patterns with unique strings. I personally like using Metasploit's `pattern_create` and `pattern_offset` Ruby scripts, but feel free to use whatever you'd like. Let's create our string with the `pattern_create.rb` script. 

The following command to do this would be `./pattern_create.rb -l 2304`, since we managed to overwrite EIP and caused an access violation with a user supplied buffer size of 0x900.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/pattern-create-stackoverflow.png" alt="">

Replace the sequence of 'A's in your PoC with the generated pattern, then copy the updated PoC over to your Debuggee machine.

Let's run the updated PoC and identify what's stored in EIP.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit3.png" alt="">

As shown in the screenshot above, we managed to overwrite EIP with `0x72433372`. Let's find out where these sequence of bytes are located in our generated pattern. We'll be using the `pattern_offset.rb` script for this.

The command we'll be running to accomplish this is `./pattern_offset -q 72433372`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/pattern-offset-stackoverflow.png" alt="">

Perfect! The Ruby script identified an instance of our bytes sequence at an offset of 0x820h (or 2080 decimal). Let's update our PoC to verify that we control EIP at this offset. We'll reintroduce a sequence of 'A's, replacing the generated pattern. However, this time we'll write 'A's up to the point of the offset, then write four bytes worth of 'B's. By using this approach, we'll be able to verify that our 'B's overwrite EIP, thus validating that we have control over the flow of execution.

Here's what our updated PoC should resemble, up to this point:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-3-py.png" alt="">

Run the updated PoC to see if we get the desired results.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit4.png" alt="">

Awesome! We've overwritten EIP with our four bytes of 'B's. We successfully control EIP 0x820h into our user supplied buffer. Now that we control the flow of execution, what do we do from here to escalate privileges on the target system? While there are quite a few techniques to escalating privileges, in this post we'll cover the Tokenstealing technique.

Privilege Escalation
---



Maintaining Integrity
---



Wrapping Up
---