---
title:  "Under Construction - HEVD Driver Exploitation - Part 2: Stack Buffer Overflow (Written in both Python and C)"
date:   2020-07-14
tags: [posts]
excerpt: "Aimed to assist individuals who are looking to learn a little about kernel exploitation. In this blog post, we'll cover some of the basics on driver enumeration, then end with exploiting a stack buffer overflow on HEVD. I welcome you to Part 2 of the tutorial series!"
---
Overview
---
In [Part 1](https://jb05s.github.io/HEVD-Driver-Exploitation-Part-1/), we went through the process of setting up our debugging environment. In this part, we'll be taking a closer look into the HackSysExtremeVulnerable driver. First, we'll begin by covering some reverse engineering basics (i.e. Driver Enumeration). After we've performed sufficient enumeration of the kernel driver, we'll proceed by looking into the stack buffer overflow bug within the HEVD driver. For the exploitation portion of this post, I'll be demonstrating the exploitation process by writing the code in both Python and C.

Let's get started!

Windows Kernel Drivers
---
To start things off, let's cover what a driver is and how we (as users) can interact with drivers.

(Need to complete this section later..)

Driver Analysis
---
Using IDA, navigate to the `Imports` windows and locate the `IoCreateDevice` function. In order for a client to obtain a handle to a driver object, a driver needs to expose at least one device object. This is created through `IoCreateDevice`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice.png" alt="">

After finding `IoCreateDevice`, double-click on the function, and then right-click on the function and select `Jump to xref to operand`. This will list the all the pointers/references for the function within the driver.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice-references.png" alt="">

As we can see, there's only one reference within the driver for `IoCreateDevice`. Let's process to jump the the reference location to analyze the the surrounding subroutines. What we're looking for within this function is a reference to the name of the device being created within the HEVD.sys driver. This is known as a symbolic link. Symbolic links are used for clients to create a handle to the device object. It allows for interaction to exist between the client and the device driver. Without much effort, we're able to successfully find the call that discloses the name of the device being created, `"\\Device\\HackSysExtremeVulnerableDriver"`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iocreatedevice-devicename.png" alt="">

Following the enumeration of the device name, we also need to identify any and all IO Control codes within HEVD.sys. Every IO Control code, defined by the device driver, performs a unique set of actions. A good way to identify these IO Control codes is through the `IofCompleteRequest` import function in IDA. `IofCompleteRequest` is used to complete IRP requests to the driver. In order for a IRP request to a driver to succeed, a valid IO code needs to be passed to the driver.. making `IofCompleteRequest` a viable function to use for identifying and calculating IO codes accepted by the driver.

Making our way back to the `Imports` window, and performing the same process used for the `IoCreateDevice` function, we can see there's quite a few pointers and references to the `IofCompleteRequest` function. In this list of pointers/references, we see one to `IrpDeviceIoCtlHandler`. This is our point of interest for fingerprinting valid IO codes for IRP requests from clients. You can think of a DeviceIoCtlHandler, or a DeviceIoControl dispatch routine for that matter, as the manager of client IRP requests.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-references.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-refjump.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-ioctlcodes.png" alt="">

After jumping into the reference to `IrpDeviceIoCtlHandler`, and crawling our way to the top of the subroutine, we can begin to identify some Io codes the driver accepts and how to calculate them. For a different viewing of the Io Codes, simply right-click in the window and select `Graph View`, as seen in the figure below. This view can be helpful in visualizing the calculations, and the branches within the `IrpDeviceIoCtlHandler` routine.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-imports-iofcompleterequest-ioctlcodes-graph.png" alt="">

Now that we've identified the symbolic link exposed from the driver and a list of valid IO codes accepted, we can now move forward in identifying the stack overflow bug and then begin building our exploit.

Bug Analysis
---
The first thing we need to do is identify which IO code corresponds to the stack overflow bug. Luckily for us, HEVD is very verbose and makes identifying the bug classes and their associated IO code relatively easy (Don't get used to it!!). With a quick look into the `IrpDeviceIoCtlHandler` routine, and analyzing the conditional jumps for each IO code, we see that the IO code for the stack overflow is `0x222003`.

Now we need to analyze the function and see what needs to be done to trigger the stack overflow.

In IDA, we can navigate over to the `Functions` table and search for function names that contain `stack`. As we'll see, there's several functions that have references to stack overflow. (We will not be covering the /GS stack cookie version in this post).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-functions-stack-overflow.png" alt="">

Jumping into the `TriggerBufferOverflowStack` function, we can analyze what's going on.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/ida-triggerbufferoverflowstack.png" alt="">

In the visual above, we can identify that the buffer buffer size is of 0x800h (2048 in decimal). Analyzing a bit further down, we can notice that the user supplied buffer size is being passed on without validating against the size of the kernel buffer (right before memmove is called). This is also described in the `BufferOverflowStack.c` file, provided by the HackSys Team.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bufferoverflow-sourcecode.png" alt="">

Perfect! Up to this point, we now know the following:
- The symbolic link used by HEVD for client's to open a handle to the driver is `"\\Device\\HackSysExtremeVulnerableDriver"`
- The IO code for making an IRP request to the stack overflow vulnerability is `0x222003`
- The user supplied buffer size needs to be greater than 0x800h (or 2048 decimal) to trigger the bug.

This is enough information for us to begin building our exploit.

Exploitation - Windows 7 SP1 (x86)
---
For the exploitation process, I will be showcasing the code in both Python and C (to show my appreciation for both languages). The first step in the exploit process is to open a handle to the driver object. As mentioned before, this is essential, as it's used for the client to interact with the device driver. This process can be done through the use of the `CreateFileA()` API function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/msdn-createfilea.png" alt="">

As shown in the above snippet, the first parameter (`lpFileName`) is where we'll pass the name of the symbolic link exposed by the device driver. With the handle to the driver object, we then must then initiate interaction with the driver through the `DeviceIoControl()` API function.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/msdn-deviceiocontrol.png" alt="">

As you see in the snippet above, we need to pass the handle to the driver object we setup in `CreateFileA()` to `DeviceIoControl()`, as the first parameter. Additionally, in second parameter, we need to supply the IO code we wish to make a request to; which we already identified earlier as `0x222003`. Lastly, parameters three and four (`lpInBuffer` and `nInBufferSize`) is where we need to pass our user supplied buffer. With all these factors taken into account, here's what our initial code will look like.

Initial exploit code in C:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-initial-c.png" alt="">

Initial exploit code in Python:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-initial-py.png" alt="">

Now that our initial PoC is ready, let's jump over to our test environment that we setup in the last post. Once our environment is up and running, and we have a successful COM between the Debugger and Debuggee machines in WinDBG, let's copy over the initial PoC to our Debuggee machine. Before we run our code, let's setup a breakpoint in WinDBG at `TriggerStackOverflow`, to verify whether or not we hit our intended target.

With the breakpoint set, we can now run our PoC on the Debuggee machine to see if we hit our breakpoint and analyze the behavior.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/stack-overflow-no-issue.png" alt="">

As we can see, we hit our breakpoint. However, if we allow execution to continue, the driver fulfills the client request and we don't trigger the underlying bug. That's because we didn't pass a buffer size large enough to overflow into adjacent memory to cause critical data to be overwritten. In the current case, We've merely provided the maximum size in memory set aside for the user buffer.

In our next case, let's try passing a larger user supplied buffer to see if that causes the behavior we're looking for. Instead of passing 0x800h, let's pass a buffer size of 0x900h (2304 in decimal).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-2-py.png" alt="">

With our updated PoC, let's copy it over to the debuggee machine and run it to analyze its behavior (our breakpoint should still be set, so nothing needs to be updated in WinDBG).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit2.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/access-violation-stack1.png" alt="">

Bingo! We've successfully overwritten EIP with the updated user supplied buffer size and hit an access violation. Cool.. so we have a vanilla EIP overwrite, but where do we go from here?

We need to locate the offset in our user supplied buffer at where we control EIP. By finding the offset to EIP, we can control the flow of execution and have the ability to introduce our own code to get executed.

But how can we find the offset? We can introduce a string composed of unique patterns to replace our sequence of 'A's. With this unique pattern, we'll be able to identify the offset of EIP by comparing the bytes stored in EIP, during the time the access violation occurs, to our unique string. There are a lot of great resources out there that assist in creating patterns with unique strings. I personally like using Metasploit's `pattern_create` and `pattern_offset` Ruby scripts, but feel free to use whatever you'd like. Let's create our string with the `pattern_create.rb` script. 

The following command to do this would be `./pattern_create.rb -l 2304`, since we managed to overwrite EIP and caused an access violation with a user supplied buffer size of 0x900.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/pattern-create-stackoverflow.png" alt="">

Replace the sequence of 'A's in your PoC with the generated pattern, then copy the updated PoC over to your Debuggee machine.

Let's run the updated PoC and identify what's stored in EIP.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit3.png" alt="">

As shown in the screenshot above, we managed to overwrite EIP with `0x72433372`. Let's find out where these sequence of bytes are located in our generated pattern. We'll be using the `pattern_offset.rb` script for this.

The command we'll be running to accomplish this is `./pattern_offset -q 72433372`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/pattern-offset-stackoverflow.png" alt="">

Perfect! The Ruby script identified an instance of our bytes sequence at an offset of 0x820h (or 2080 decimal). Let's update our PoC to verify that we control EIP at this offset. We'll reintroduce a sequence of 'A's, replacing the generated pattern. However, this time we'll write 'A's up to the point of the offset, then write four bytes worth of 'B's. By using this approach, we'll be able to verify that our 'B's overwrite EIP, thus validating that we have control over the flow of execution.

Here's what our updated PoC should resemble, up to this point:

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/exploit-3-py.png" alt="">

Run the updated PoC to see if we get the desired results.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/bp-windbg-triggerbufferoverflowstack-hit4.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/windbg-eip-control.png" alt="">

Awesome! We've overwritten EIP with our four bytes of 'B's. We successfully control EIP 0x820h into our user supplied buffer. Now that we control the flow of execution, what do we do from here to escalate privileges on the target system?

Privilege Escalation
---
Now that we successfully control the flow of execution, we need to introduce shellcode that will result in us gaining elevated privileges on the local Windows system (`NT AUTHORITY\SYSTEM`). There's quite a few known techniques that can be used to reach our goal, but for the purposes of this walkthrough I'll be demonstrating the token stealing technique (I'll cover other techniques in later posts).

The goal in the token stealing privilege escalation technique is to locate and replace a selected process' token with that of a more privileged token (i.e. SYSTEM). 

In Windows, everything can be conceptualized as an object. Each object has a security descriptor that specifies what activities an entity can perform on an object. A token, or namely access token, contains all the relative information pertaining to the rights and privileges of a given entity. 

In order for us to replace our selected process' token with an access token of higher privileges, we must first understand some key data structures. Let's take a look at these data structures.

KPCR Structure
---
In Windows, processor information is stored within the Kernel Processor Control Region (KPCR) data structure. The KCPR structure is always indexed in segment register `FS:[0]` on Windows x86 (or `GS:[0]` on Windows x64). We can view the structure in WinDBG with the following command: `dt nt!_KPCR`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/kpcr-structure.png" alt="">

Upon analysis, there's quite a few members in the KPCR data structure. However, the member in the list we're interested in is the offset to the KPRCB data structure.

KPRCB Structure
---
Within the KPCR data structure, we obtain the Kernel Processor Control Block (KPRCB) data structure. The KPRCB structure holds most of the information the kernel needs for resource management. Below is a visual of the KPRCB data structure in WinDBG - using the following command: `dt nt!_KPRCB`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/kprcb-structure.png" alt="">

In the above snippet, the member we're interested in within the KPRCB data structure is the offset to the current KTHREAD data structure.

KTHREAD Structure
---
The KTHREAD data structure is part of a larger data structure known as the ETHREAD structure. Here, we'll find information about the thread currently executing. We can dump the table for viewing in WinDBG with the `dt nt!_KTHREAD` command.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/kthread-structure.png" alt="">

While this data structure holds a daunting amount of information, our interest for the purposes of the technique is the offset to the ApcState member that points to the KAPC_STATE data structure.

KAPC_STATE Structure
---
The KAPC_STATE data structure is used for threads to survey processes it's associated with. As it relates to our privilege escalation technique, this structure holds some vital information we're needing. The `dt nt!_KAPC_STATE` command can be run in WinDBG to analyze the data structure and its members.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/kapc_state-structure.png" alt="">

As seen above, the data structure contains very few members. The Process member is our point of interest here. This member holds a pointer to the KPROCESS data structure. Similar to to the KTHREAD structure, the KPROCESS structure is part of a larger data structure known as the EPROCESS structure. Now, let's take a look at the EPROCESS structure.

EPROCESS Structure
---
The EPROCESS data structure is the crown jewel. This structure contains members holding data to that which are necessary for our token stealing technique. Let's take at look at the data structure and its members of interest with the following command: `dt nt!_EPROCESS`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/eprocess-structure.png" alt="">

In the snippet above, There's three members within the EPROCESS structure that are points of interest.

EPROCESS.UniqueProcessId 
--- 
This member holds the PID of the current process. Since this is the target privileged process in the token stealing technique, this member will play a role in identifying the `SYSTEM` process. Conveniently, the SYSTEM process is always running with a PID value of 4. To validate this, we can query the address of the SYSTEM process and add the offset to EPROCESS.UniqueProcessId.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/eprocess-uniqueprocessid.png" alt="">

EPROCESS.ActiveProcessLinks
---
This member in the EPROCESS structure is a doubly-linked list (pointers to the previous and following nodes) containing all other active processes on the local system.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/eprocess-activeprocesslinks.png" alt="">

EPROCESS.Token
---
The Token member in the EPROCESS structure contains the access token assigned to the process. This is the privileged data we want to copy over to our selected process.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/eprocess-token.png" alt="">

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/eprocess-token-calc.png" alt="">

Token Stealing Shellcode - Putting it All Together
---
While there are a few ways of writing the payload, I'll stick to presenting the version by [HackSys](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Exploit/Payloads.c).

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/tokenstealing-skeleton.png" alt="">

As seen in the code snippet above, we're needing to provide the offsets to members within some of the key data structures, previously mentioned. Let's walk through the calculations now.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/tokenstealing-skeleton-offsets.png" alt="">

The information in the above visual presents the offsets we're needing to supply to the code. Let's discuss how these offset values were calculated.

1. **SYS_PID** - This is the statically assigned PID value for the SYSTEM process.
2. **PID_OFFSET** - This value is the offset where the UniqueProcessId member is located within the `_EPROCESS` data structure.
3. **TOKEN_OFFSET** - This value is the offset where the Token member is located within the `_EPROCESS` data structure.
4. **FLINK_OFFSET** - This value is the offset where the ActiveProcessLinks member is located within the `_EPROCESS` data structure.
5. **KTHREAD_OFFSET** - This value is calculated by taking the offset sum of `_KPCR.ProcData` (0x120h) and `_KPRCB.CurrentThread` (0x004h). 
6. **EPROCESS_OFFSET** - This value is calculated by taking the offset sum of `_KTHREAD.ApcState` (0x040h) and `_KAPC_STATE.Process` (0x010h).

Now that some light has been shined on how the values were comprised, let's analyze what's being performed in the payload.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/tokenstealing-skeleton-s1.png" alt="">

In the first part of the payload, we're just setting up some registers to point to where the CurrentThread and the CurrentProcess members are located. Following, in the EDX register, we're storing the statically assigned SYSTEM PID.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/tokenstealing-skeleton-s2.png" alt="">

In the code snippet above, this is where the query begins. We're going to be crawling each active process on the local system, until we hit the SYSTEM process. If the indexed PID does not equal the value of `4`, we'll increment the index to check the next PID.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/tokenstealing-skeleton-s3.png" alt="">

After finding the SYSTEM process, we jump to the code snippet seen in the above visual. Here, we copy the access token of the SYSTEM process and replace the access token of the target process with the SYSTEM token.

To review - the steps performed in the token stealing payload:
1. Obtain the pointers to KTHREAD and EPROCESS
2. Crawl the ActiveProcessLinks doubly-linked list, until we find the PID of SYSTEM
3. Save the SYSTEM token and replace the token in the target process (attacker's process) with the SYSTEM token
4. Restoring Execution/Maintaining Integrity

Notice that the `4. Restoring execution/Maintaining Integrity` has not been discussed yet. Let's dive into this step now.

Restoring Execution/Maintaining Integrity
---
Now that we understand the process of the token stealing payload that will result in gaining `NT AUTHORITY\SYSTEM`, we have one last piece of code discuss in the payload. 

The last piece of code deals with restoring the flow of execution in the driver. If we fail to perform this last step, it will indefinitely lead to a system crash. 

The idea here is to put everything back to the way we found it. Luckily, in this attack scenario, we can save the state of the registers before executing the token stealing payload. Then, after the token stealing payload is completed, we can restore the register states. This is made possible, only on x86 architecture, with the `PUSHAD/POPAD` instructions. Once we restore the state of the registers, we can point the driver to the set of instructions following the call to subroutine containing the bug. 

This can be seen in WinDBG with the following command: `u HEVD!StackOverflowIoctlHandler+10`.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/restoring-execution.png" alt="">

As we can see here, there's two instructions proceeding the return from `HEVD!TriggerStackOverflow` - `POP EBP; RET 0x8;`. These two instructions, along with setting a STATUS_SUCCESS code, that we need to reintroduce at the end of the token stealing payload to restore execution to the driver.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/restoring-execution-code.png" alt="">

Now with an understanding of the token stealing payload, we can assemble the code with Nasm, and retrieve the contents of the payload using Hexdump.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/payload.png" alt="">

Here's the breakdown of the token stealing shellcode we're going to implement into our exploit.

<img src="{{ site.url }}{{ site.baseurl }}/images/hevd-pt2/payload-exploit.png" alt="">

The Final Hurdle - Data Execution Prevention (DEP)
---

Leveling Up - Windows 10 RS2 (x64)
---



Wrapping Up
---